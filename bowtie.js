/* ================================================================================================
 *    _        _
 *   | \      / | 
 *   |  \ __ /  |
 *   |   |__|   |
 *   |  /    \  |
 *   |_/      \_| 
 * 
 *   Bowtie.js
 *   @version 2.0.0
 *
 *   A super-classy client-side templating system.
 *   Lots of features, commands, and familar syntax.
 *
 *   @author Geoff Daigle
 *
 * ================================================================================================
 */

// browser or node top-level object
var thewindow = (typeof window !== 'undefined')? window : global;


(function( thewindow, undefined ) {

// set up the class varibales
var 

	/**
	 	Shortcuts to core javascript functions
	 */
	array_indexOf = Array.prototype.indexOf,
	object_toString = Object.prototype.toString,
	object_hasOwnProp = Object.prototype.hasOwnProperty,
	string_trim = String.prototype.trim,

	
	/**
	 	Shortcuts for regex searches
	 */

	// {{ anything }}
	reg_all_bowties = /\{\{(.*?)\}\}|.((?!\{\{.*\}\}).)*/g,
	// {{ anything }}  non-global
	reg_check_bowtie = /\{\{(.*?)\}\}/,
	// only selects the space at the very beginning and very end of a string
	reg_trim_ends = /^\s+|\s+$/,
	// for \s that are in a row (like \s\s\s\s\s)
	reg_big_spaces = /[\s]{1,1000}/g,
	// for removing all brackets only
	reg_brackets = /\{\{|\}\}/g,
	// (Taken from jQuery)
	str_reg_all_whitespace = "[\\x20\\t\\r\\n\\f]";
	// (Taken from jQuery)
	reg_trim = new RegExp( "^" + str_reg_all_whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + str_reg_all_whitespace + "+$", "g" ),


	/**
		Populated later - holds strings for use with util.get_type
		@private
	 */
	class_types = {},

	/**
		A collection of function names and code to do variable manipulation 
		@private
	 */
	registered_plugins = [],


	/**
		The amount of time it took to fully render a template when populate() was last called
		@private
	 */
	last_render_time = '0',


	/**
	 	Initializer for the window.bowtie object	
		@public
	 */
	bowtie_app = function() {
		return bt;
	},


	/**
    	@namespace Object which contains all of the publicly-available functions
    	@public
	*/
	bt_factory = bt = {},


	/**
    	@namespace Template markup goes here for storage when imported
    	@private
	*/
    template_cache = {},


    /**
	 	@namespace A place to store data manipulation functions. All plugins are appended here.
	 	@private
	 */
    fn = {},


    /**
	    @namespace Utility functions to help with template parsing and population
	    @private
	*/
	util = {},


	/**
	    Keeps track of the hierarchy of foreach loops
	    @private
	*/
	loop_tiers = 0,


	/**
	    Keeps track of the hierarchy of if blocks
	    @private
	*/
	if_tiers = 0,


	/**
	    Keeps track of the hierarchy of "with" blocks
	    @private
	*/
	with_tiers = 0,


	/**
	    When making a copy of data to use in the "with" statements, add it here
	    @private
	*/
	with_data_cache = [],

	/**
	    When making a copy of data to use in loops and includes, add it here
	    @private
	*/
	loop_data_cache = [],


	/**
	    The array of tokens is stored here once it's generated by the parser
	    @private
	*/
	template_tokens = [];




    //---------------------------------------------------------------------------------------------
	// Public functions


	/**
	   	The main function which takes a template (or templates) and populates them with data from
	   	an included object. This function is COMPILE and RENDER all at once with NO CACHING.

	    @name bowtie.populate
	    @public
	    @function
	    @param {String|String[]} A string or array of strings
	    @param {Object} An object with all of the data to be imported into the template
	    @returns {String} The template with all {{ }} tags handled and replaced
	 */
	bt_factory.populate = function($template_raw, $input_data) {
		// Get the full template in question and mount the data to be imported
		var bench_start = new Date().getTime(), bench_end,
			global_data = $input_data,
			template_key = {};
		 

		// ------------------------------------
		//	Tokenize
		// ------------------------------------

		template_key = bt.compile($template_raw);

		// ------------------------------------
		//	Render
		// ------------------------------------

		working_template = bt.render(template_key, global_data);

		// get the benchmark time and save it
		bench_end = new Date().getTime();
		last_render_time = bench_end - bench_start;

		if (bt_factory.debug === true) {
			console.log('Bowtie: Generated template in '+bt.last_render_time());
		}

		// clear cache
		template_tokens = [];

		// order up!
		return working_template;
	};


	/**
	   	Only does the compilation step. This returns the object that can be used to compile a template.

	    @name bowtie.compile
	    @public
	    @function
	    @param {String|String[]} A string or array of strings
	    @returns {Object} A "key" object to render the cached template
	*/
	bt_factory.compile = function($template_raw) {
		var working_template = util.compile_raw_template($template_raw),
			key_id = 'bt_template_'+util.random_hash();

		fn.build_tokens(working_template);

		template_cache[key_id] = template_tokens;

		template_tokens = [];

		return { template_key_id: key_id };

	};


	/**
	   	Takes a 'key' of data or a string with the key and compiles the data into a string.
	   	It is recommended that you use this function multiple times and compile only once.

	    @name bowtie.render
	    @public
	    @function
	    @param {String|String[]} A string or array of strings
	    @returns {Object} A "key" object to render the cached template
	*/
	bt_factory.render = function($template_key, $global_data) {
		var passdata = {};
		if ($global_data !== undefined && typeof $global_data === 'object'){
		 	passdata = util.object_merge(true, {}, $global_data);
		}

		if (util.get_type($template_key) === 'string') {
			$template_key = { template_key_id: key_id };
		}

 		var template_data = util.object_rsearch($template_key.template_key_id.split('.'), template_cache);

 		if (template_data !== null) {
 			template_tokens = template_data.slice(0);
 			working_template = fn.parse_tokens(passdata);
 			// reset some class vars
 			fn.reset_class_vars();
 			// ship 'er out.
 			return working_template;
 		} else {
 			// reset for good measure
 			fn.reset_class_vars();
 			// well then... this is bad.
 			console.error('ERROR: bowtie.render: "'+$template_key.template_key_id+'" is not a valid or available template key');
 			return '';
 		}
	};


	/**
    	Toggle debug info

    	@public
	*/
	bt_factory.debug = false;


	/**
	   	Shorthand for running populate without passing any data. 
	   	Typically used for fetching data.

	    @name bowtie.get
	    @public
	    @function
	    @param {String|String[]} A string or array of strings
	    @returns {String} The template with all {{ }} tags handled and replaced
	 */
	bt_factory.get = function($template_raw) {
		return bt.populate($template_raw, {});
	};


	/**
	   	Searches through the cached templates 
	   	Only used for fetching data.

	    @name bowtie.get_raw
	    @public
	    @function
	    @param {String} A string specifying the name of the cached template
	    @returns {String} The template with NO ALTERATIONS
	 */
	bt_factory.get_raw = function($template_key) {
		return util.compile_raw_template($template_key);
	};


	/**
	   	Takes an object of template strings and pushes it to the template_cache variable

	    @name bowtie.load
	    @public
	    @function
	    @param {String|Boolean} the template key to call when loading the template, or true
	    @param {string} teh template object
	    @returns {Boolean} True if success, false if not.
	 */
	bt_factory.load = function($template_key, $template_str) {

		// overwrite everything if first param is true because we have json
		if ($template_key === true && util.get_type($template_str) === 'object') {
			template_cache = $template_str;
			return true;
		}

		if (util.get_type($template_str) !== 'string' || util.get_type($template_key) !== 'string' ) {
			return false;
		}

		var template_pointer = template_cache,
			key_steps = $template_key.replace(/\s/g, '').split('.'),
			key_pointer;


		// get the right pointer object
		while (key_steps.length !== 0) {
			key_pointer = key_steps.shift();
			// if the object doesnt exist, create it
			if (template_pointer[key_pointer] === undefined) {
				template_pointer[key_pointer] = {};
			}
			// re-orient
			if (key_steps.length !== 0) {
				template_pointer = template_pointer[key_pointer];
			}
		}
		// save the template
		template_pointer[key_pointer] = $template_str;
		return true;
	};


	/**
    	A pointer to an object which contains client-side data used for populating templates.
	    This is optional and allows users to utilize the {{include:VAR as ALIAS}} function.

	    @public
	*/
	bt_factory.db_pointer = {};


	/**
	   	Takes a plugin function and adds it to the registered_plugins array for later use

	    @name bowtie.register_plugin
	    @public
	    @function
	    @param {String} The name of the plugin
	    @param {RegExp} The regex selector to match against the tag
	    @param {Function} The plugin function
	    @returns {Boolean} True if success, false if name is in use.
	 */
	bt_factory.register_plugin = function($plugin_name, $plugin_compile, $plugin_function) {
		// no name? no plugin
		if (util.get_type($plugin_name) !== 'string') {
			return false;
		}

		var can_add = true, sel_is_func = util.get_type($plugin_compile) === 'function',
			reserved_names = ['if', 'elseif', 'with', 'get', 'include', 'foreach', 'template'];
		
		$plugin_name = util.trim($plugin_name.toLowerCase());

		// thwart attempts to override reserved keywords...
		if (util.in_array($plugin_name, reserved_names) !== -1) {
			return false;
		}

		// ...also if we already registered it under the same name
		util.for_each(registered_plugins, function($i, $val) {
			if ($plugin_name === $val.name) {
				can_add = false;
				return false;
			}
		});

		// if this is the case, we have both a compile and render function
		if (util.get_type($plugin_function) === 'function' && sel_is_func) {
			can_add = true;
			registered_plugins.push({
				name: $plugin_name,
				compile_func: $plugin_compile,
				runtime_func: $plugin_function
			});
		} else {
			can_add = true;
			registered_plugins.push({
				name: $plugin_name,
				selector: null,
				runtime_func: $plugin_compile
			});
		} 

		return can_add;
	}; 


	/**
	   	Returns the amount of time the last template rendering took

	    @name bowtie.last_render_time
	    @public
	    @function
	    @returns {String} The last render time in miliseconds
	 */
	bt_factory.last_render_time = function() {
		var t_render = last_render_time;
		if (t_render === 0){
			return 'less than 1 ms';
		} else {
			return String(t_render)+'ms';
		}	
	};


	/**
	   	Returns the template_cache object with all saved templates

	    @name bowtie.get_templates
	    @public
	    @function
	    @returns {Object} The template_cache object
	 */
	bt_factory.get_templates = function() {
		return template_cache;
	};




	//---------------------------------------------------------------------------------------------
	// Token workhorse functions


	/**
	  	Hard reset of bowtie provate variables to initial state

	    @name fn.reset_class_vars
	    @private
	    @function
	 */
	fn.reset_class_vars = function () {
		passdata = {};
		template_tokens = [];
		loop_data_cache = [];
		loop_tiers = 0;
		if_tiers = 0
		with_tiers = 0;
	};


	/**
	  	Walk through the template and parse into digestable tokens

	    @name fn.build_tokens
	    @private
	    @function
	    @param {String} The template string
	 */
	fn.build_tokens = function( $working_template ){
		var last_was_string = 0,
			t_index = 0;
		while (repmatch = reg_all_bowties.exec($working_template )) {
			if (repmatch[0].indexOf('{{') !== -1) {
				template_tokens.push(fn.evaluate_token_handler(repmatch[0]));
			} else {
				// concatinate strings that are adjacent now to save processing time after compilation
				if (last_was_string === 1) {
					t_index--;
					template_tokens[t_index] = template_tokens[t_index]+repmatch[0];
				} else {
					template_tokens.push(repmatch[0]);
				}
			}
            t_index++;
        }
    };


    /**
	  	Check for instances of a tag type and include the appropriate function

	    @name fn.evaluate_token
	    @private
	    @function
	    @param {String} A sting that is in the format of a token ( has {{ }} brackets)
	    @returns {function|string} An evaluation, either a token object or a string
 	 */
	fn.evaluate_token_handler = function( $token_tag ){
		var tag_split = util.trim($token_tag.replace(reg_brackets, '')).split(':');
		// if no colon, we probably have a variable, end tag, or a comment ...
		if (tag_split.length === 1){
			// comment
			if (tag_split[0].indexOf('%') === 0){ 
				return fn.token_noaction('comment');

			// else/endif
			} else if (tag_split[0].indexOf('else') === 0){ 
				return fn.token_noaction('else');
			} else if (tag_split[0].indexOf('endif') === 0){ 
				return fn.token_endif();

			// endforeach
			} else if (tag_split[0].indexOf('endforeach') === 0){ 
				return fn.get_foreach_parent_pos();	

			// endwith
			} else if (tag_split[0].indexOf('endwith') === 0){ 
				return fn.token_endwith();	

			// regular variable
			} else { 
				return fn.token_variable(tag_split[0]);
			}

		// otherwise, check for a tag type
		} else {

			// if-elseif
			if (tag_split[0].indexOf('if') === 0){
				return fn.token_if((tag_split[0].indexOf('!')!==-1), util.trim(tag_split[1]), 'if');
			} else if (tag_split[0].indexOf('elseif') === 0){ 
				return fn.token_if((tag_split[0].indexOf('!')!==-1), util.trim(tag_split[1]), 'elseif');

			// foreach
			} else if (tag_split[0].indexOf('foreach') === 0){ 
				return fn.token_foreach(util.trim(tag_split[1]), util.trim(tag_split[0]));		

			// with
			} else if (tag_split[0].indexOf('with') === 0){ 
				return fn.token_with(util.trim(tag_split[1]));							

			// get
			} else if (tag_split[0].indexOf('get') === 0){ 
				return fn.token_get(util.trim(tag_split[1]));	;				

			// template (TODO)
			/*} else if (tag_split[0].indexOf('template') === 0){ 
				return 'TEMPLATE';		
			*/	

			// include	
			} else if (tag_split[0].indexOf('include') === 0){ 
				return fn.token_include(util.trim(tag_split[1]));					
			} 

			var tag_trim = util.trim(tag_split[0]);
			var plugin_func = util.get_var_mod_function(tag_trim);
			if (plugin_func !== null) {
				return fn.assign_plugin_handler(tag_trim, util.trim(tag_split[1]), plugin_func);
			}

			// no matches? oh well.
			return '';
		}
		
    };


    /**
	  	Evaluate template tokens one at a time in a loop

	    @name fn.parse_tokens
	    @private
	    @function
	    @param {Object} The data object passed by the user
	    @returns {String} The fully rendered template string
	 */
	fn.parse_tokens = function( $global_data ){
		var pos = 0,
			template_length = template_tokens.length,
			return_string = '', return_func = '', return_type = '';
		for (; pos < template_length; pos++) {
			if (util.get_type(template_tokens[pos]) == 'object') {
				return_func = template_tokens[pos].action($global_data, pos);
				return_type = util.get_type(return_func);
				if (return_type ==  'object') {
					if ( typeof return_func.go_to !== 'undefined' ){
						pos = return_func.go_to - 1;
						if ( typeof return_func.data_adjust !== 'undefined' ){
							$global_data = return_func.data_adjust;
						}
					} else {
						return_string += return_func.string
						$global_data = return_func.data_adjust;
					}
				} else {
					return_string += return_func;
				}
			} else {
				return_string += template_tokens[pos];
			}
		}

		return return_string;
    };




    //---------------------------------------------------------------------------------------------
	// Token Handlers


    /**
	  	Token which returns a blank string and no modifications

	    @name fn.token_noaction
	    @private
	    @function
	    @param {Object} Tag type (endwith, comment, etc)
	    @returns {Object} A token object
	 */
    fn.token_noaction = function( $type ) {
    	if ($type === 'endforeach') {
    		loop_tiers--;
    	} else if ($type === 'endwith') {
    		with_tiers--;
    	}

    	return {
    		type: $type, 
    		action: function() { return ''; } 
    	};
    };


    /**
	  	Token which returns a blank string and no modifications

	    @name fn.token_noaction
	    @private
	    @function
	    @param {Object} Tag type (endwith, comment, etc)
	    @returns {Object} A token object
	 */
    fn.token_variable = function( $varname ) {
    	var $steps = util.trim($varname).split('.');
    	var t_action = function($data) {
    		var the_var = util.object_rsearch($steps, $data);
    		return  (the_var!== null) ? the_var:''; 
    	};

    	return {
    		type: 'var',
    		action: t_action
    	};
    };


    /**
	  	Token handler for "if" statements

	    @name fn.token_if
	    @private
	    @function
	    @param {Booleam} True if the statement value should be inverted
	    @param {String} The string containing the variable names in question
	    @param {String} If or elseif
	    @returns {Object} A token object
	 */
    fn.token_if = function($inverse, $varname, $type) {
    	var $steps = util.trim($varname), var_compare = true,
    		target_var = '', comparison_var = '';

    	if ($varname.indexOf('?=') !== -1) {
    		comparison_var = $varname.split('?=');
    		target_var = $comparison_var[0];
    		comparison_var = util.trim(comparison_var[1]);
    	} else if ($varname.indexOf('=') !== -1) {
    		comparison_var = $varname.split('=');
    		target_var = $comparison_var[0];
    		comparison_var = util.trim(comparison_var[1]);
    		var_compare = false;
    	} else {
    		target_var = $varname;
    	}
    	comparison_var = comparison_var.split('.');
    	target_var = util.trim(target_var).split('.');
    	
    	
    	var t_action = function($data, $pos) {
    		var pass_comparison_var = null, eval_var = null;
    		if ($type === 'if'){
	    		if_tiers++;
	    	}
	   
    		eval_var = util.object_rsearch(target_var, $data);
    		if (var_compare) {
    			pass_comparison_var = util.object_rsearch(comparison_var, $data);
    		} 

    		evaluate = fn.determine_evaluate(eval_var, $inverse, pass_comparison_var);

    		if (evaluate) {
    			return '';
    		} else {
    			return fn.get_next_if_statement_pos( $pos );
    		}
    	};

    	return {
    		type: $type, 
    		action: t_action
    	};
    };


    /**
	  	Token handler for "foreach" statements

	    @name fn.token_foreach
	    @private
	    @function
	    @param {String} The string containing the variable names in question
	    @param {String} The string with the actual foreach command and modifiers
	    @returns {Object} A token object
	 */
    fn.token_foreach = function( $varname, $loop_command ) {
    	var $steps = util.trim($varname).split('.'),
    		command = $loop_command.split('('),
    		has_aliases = false, inner_command = '',
    		alias_index = '', alias_value = '';

    		if (typeof command[1] !== 'undefined') {
    			inner_command =  util.trim(command[1]);
    			if (inner_command.indexOf(')') !== -1) {
    				inner_command = util.trim(( inner_command.split(')') )[0]);
    				if (inner_command !== '') {
    					var alias_split = inner_command.split(',');
    					if (alias_split.length > 1) {
    						alias_index = util.trim(alias_split[0]);
    						alias_value = util.trim(alias_split[1]);
    					} else {
    						alias_value = util.trim(alias_split[0]);
    					}
    					has_aliases = true;
    				}
    			}
    		}

    	var t_action = function( $data, $pos ) {
    		loop_tiers++;
    		if (this.countdown !== null) {
    			this.countdown--;
				if (this.countdown === 0) {
					this.countdown = null;
					this.i = 0;
					this.alias_index = '';
	    			this.alias_value = '';
	    			this.has_aliases = false;
    				properties = [];
					return fn.get_foreach_end_pos($pos);
				} 
			}
    		var loopvar = util.object_rsearch($steps, $data);
			// merge the data
			if (loop_tiers === 1) {
				var safecopy = util.object_merge(true, {}, $data);
				loop_data_cache.push(safecopy);
			} 
    		if (loopvar !== null) {
    			if (this.countdown === null) {
   
    				// prep the counters
    				this.countdown = util.get_length(loopvar);
    				this.properties = util.get_loopable_props(loopvar);
    				this.alias_index = alias_index;
	    			this.alias_value = alias_value;
	    			this.has_aliases = has_aliases;
    			}

    			// pass approproate data for aliases or non-aliased
    			if (has_aliases) {
    				var aliasobject = {};
    				if (alias_index !== '') {
    					aliasobject[this.alias_index] = ""+this.i+"";
    				}
    				aliasobject[this.alias_value] = this.properties[this.i];
    				var passdata = util.object_merge(true, {}, $data, aliasobject );
    			} else {
	    			var passdata = util.object_merge(true, {}, $data, this.properties[this.i] );
	    		}

    			loop_data_cache.push(passdata);

    			this.i++;

    			return {string: '', data_adjust: passdata}

    		} else {
    			return fn.get_foreach_end_pos($pos);
    		}
    	};

    	return {
    		type: 'foreach', 
    		countdown: null,
    		i: 0,
    		has_aliases: false,
    		alias_index: '',
    		alias_value: '',
    		properties: [],
    		action: t_action
    	};
    };


    /**
	  	Token handler for "with" statements

	    @name fn.token_with
	    @private
	    @function
	    @param {String} The string containing the variable names in question
	    @returns {Object} A token object
	 */
    fn.token_with = function( $varname ) {
    	var $steps = util.trim($varname).split('.');
    	var t_action = function($data, $pos) {
    		with_tiers++;
    		var withvar = util.object_rsearch($steps, $data);
			if (with_tiers === 1) {
				var safecopy = util.object_merge(true, {}, $data);
				with_data_cache.push(safecopy);
			} 
    		if (withvar !== null) {
    			var passdata = util.object_merge(true, {}, $data, withvar );

    			with_data_cache.push(passdata);

    			return {string: '', data_adjust: passdata}
    		} else {
    			with_data_cache.push({});
    			return '';
    		}

    	};
    	return {
    		type: 'with', 
    		action: t_action
    	};
    };


    /**
	  	Token handler for "get" statements

	    @name fn.token_get
	    @private
	    @function
	    @param {String} The string containing the variable names in question
	    @returns {Object} A token object
	 */
    fn.token_get = function( $varname ) {

    	var target_var = $varname.split('['),
        get_target = '', get_prop = '', get_val = '', var_compare = false;

        // if the split worked, we have a VAR[PROP=VAL] situation
        if (target_var.length > 1) {
        	get_prop = util.trim(target_var[1].replace(reg_big_spaces, ''));
        	if (get_prop.indexOf('?=') !== -1) {
        		get_prop = get_prop.split('?=');
        		get_val = util.trim(get_prop[1].replace(']', ''));
        		get_prop = util.trim(get_prop[0]);
        		var_compare = true;
        	} else if (get_prop.indexOf('=') !== -1) {
        		get_prop = get_prop.split('=');
        		get_val = util.trim(get_prop[1].replace(']', ''));
        		get_prop = util.trim(get_prop[0]);
        	}
        } 

       	get_target = util.trim(target_var[0]).split('.');
        	
        var t_action = function($data, $pos) {
    		var object_var = util.object_rsearch(get_target, $data),
    			comparison_result = false, the_object_adjust = {};

    		if (object_var !== null) {

    			if (util.get_type(object_var) === 'array' && get_val !== '' && get_prop !== '') {
    				util.for_each(object_var, function($i, $val) {
						if (var_compare) {
							comparison_result = fn.determine_evaluate($val[get_prop], false, $data[get_val]);
						} else {
							comparison_result = fn.determine_evaluate($val[get_prop], false, get_val);
						}

					    if (comparison_result) {
					       	// Delete the property (PROP) that we compared against because:
					       	// 1. We used an equivalent variable to find the object, and
					       	// 2. For things like primary keys, different data sets could have the same
					       	//    property names which could accidentally be overwritten (for example, ID)
					        var safety_obj = util.object_merge(true, {}, $val);
					        delete safety_obj[get_prop];
					        // merge data
					        the_object_adjust = util.object_merge(true, {}, $data, safety_obj);
					        return false;
					    } 
    				});
    			} else {
    				the_object_adjust = util.object_merge(true, {}, $data, object_var);
    			}
    			return {string: '', data_adjust: the_object_adjust};


    		} else {
    			return '';
    		}
    	};

    	return {
    		type: 'get', 
    		action: t_action
    	};

    };


    /**
	  	Token handler for "include" statements

	    @name fn.token_include
	    @private
	    @function
	    @param {String} The string containing the variable names in question
	    @returns {Object} A token object
	 */
    fn.token_include = function( $varname ) {
    	var g_include,
	    	has_alias = false,
	    	var_alias = '';

    	// clean up
    	g_include = $varname.replace(reg_big_spaces, ' ');

    	// check to see if we have an alias name and if so, prep for it by trimming
    	g_include_split = g_include.split(' as ');
    	g_include_key = g_include_split[0].split('.');
    	util.for_each(g_include_key, function($i, $val){
    		g_include_key[$i] = util.trim($val);
    	});

    	// do we have an alias?
    	if (g_include_split[1] !== undefined) {
    		var_alias = g_include_split[1];
    		has_alias = true;
    	} else {
    		var_alias = g_include_key[0];
    	}
    	// safety trim
    	var_alias = util.trim(var_alias);

    	var t_action = function($data, $pos) {
    		var temp_dataset = {}, key_array = g_include_key;

    		// get the object that's asked for from bt.db_pointer, or just pass { } if null
    		temp_dataset = util.object_rsearch(key_array, bt.db_pointer);
    		if (temp_dataset === null) {
    			temp_dataset = {};
    		}
    		// add it to our collective dataset
		    $data[var_alias] = temp_dataset;

    		return {string: '', data_adjust: $data} 
    	};
    	return {
    		type: 'include', 
    		action: t_action
    	};
    };


    /**
	  	TODO:fn.token_template
	 */
    /*fn.token_template = function() {

    };*/


    /**
	  	Token handler for "endwith" statements

	    @name fn.token_endwith
	    @private
	    @function
	    @returns {Object} A token object
	 */
    fn.token_endwith = function() {
    	return {
    		type: 'endwith',
    		action: function(){
		    	with_tiers--;
		    	with_data_cache.pop();
		    	return {string:'', data_adjust: with_data_cache[with_tiers]}; 
		    }
	    }
    };


    /**
	  	Token handler for "endif" statements

	    @name fn.token_endif
	    @private
	    @function
	    @returns {Object} A token object
	 */
    fn.token_endif = function() {
    	return {
    		type: 'endif',
    		action: function(){
		    	if_tiers--;
		    	return ''; 
		    }
	    }
    };


    /**
    	Token handler for "endforeach" statements.

	  	Walks through the tokens in reverse from the current "endforeach" tag
	  	and returns the index of the corresponding "foreach" tag.

	    @name fn.get_foreach_parent_pos
	    @private
	    @function
	    @returns {Object} A token object
	 */
    fn.get_foreach_parent_pos = function() {
    	return {
    		type: 'prev', 
    		action: function( $data, $pos ) { 
    			loop_tiers--;
    			var i = $pos - 1;
    			var current_tier = loop_tiers;
    			for (; i >= 0; i--) {
    				if (typeof template_tokens[i] !== 'string') {
    					if (template_tokens[i].type === 'prev') {
    						current_tier++;
    					}
    					if (template_tokens[i].type === 'foreach') {
    						if (current_tier === loop_tiers) {
    							break;
    						} else {
    							current_tier--;
    						}
    					}
    				}
    			}
    			if (i < 0) i = 0;
    			loop_data_cache.pop();

    			// some error handling for my sanity
    			if (loop_tiers < 0){
					throw new Error("get_foreach_parent_pos ("+loop_tiers+") loop_tier less than 0");
				}
				if (loop_data_cache[loop_tiers] === undefined){
					throw new Error("get_foreach_parent_pos ("+loop_tiers+") undefined data");
				}
    			return {go_to: i, data_adjust: loop_data_cache[loop_tiers]}; 
    		} 
    	};
    };


    /**
	  	Walks forward through each token from the current index of the "foreach" tag and 
	  	finds the corresponding "endforeach" tag.

	    @name fn.get_foreach_end_pos
	    @private
	    @function
	    @param {Integer} The current index of the token iterator
	    @returns {Object} A token response object
	 */
    fn.get_foreach_end_pos = function( $pos ) { 
		loop_tiers--;
		var i = $pos+1;
		var current_tier = loop_tiers;
		for (; i < template_tokens.length; i++) {
			if (typeof template_tokens[i] !== 'string') {
				if (template_tokens[i].type === 'prev') {
					if (current_tier === loop_tiers) {
						break;
					} else {
						current_tier--;
					}
				}
				if (template_tokens[i].type === 'foreach') {
					current_tier++;
				}
			}
		}
		if (i < 0) i = 0;

		// some error handling for my sanity
		if (loop_tiers < 0){
			throw new Error("get_foreach_end_pos ("+loop_tiers+") loop_tiers less than 0");
		}
		if (loop_data_cache[loop_tiers] === undefined){
			throw new Error("get_foreach_end_pos ("+loop_tiers+") undefined data");
		}
		return {go_to: i+1, data_adjust: loop_data_cache[loop_tiers]}; 
	};


	/**
	  	Walks forward through each token from the current index of the "if" or "elseif" tag and 
	  	finds the next corresponding "elseif", "else", or "endif" tag.

	    @name fn.get_next_if_statement_pos
	    @private
	    @function
	    @param {Integer} The current index of the token iterator
	    @returns {Object} A token response object
	 */
    fn.get_next_if_statement_pos = function( $pos ) {
    	var i = $pos+1;
    	var current_tier = if_tiers;
    	for (; i < template_tokens.length; i++) {
    		if (typeof template_tokens[i] !== 'string') {
    			if (template_tokens[i].type === 'endif' || template_tokens[i].type === 'elseif' || template_tokens[i].type === 'else') {
    				if (current_tier === if_tiers) {
    					break;
    				} else {
    					current_tier--;
    				}
    			}
    			if (template_tokens[i].type === 'if') {
    				current_tier++;
    			}
    		}
    	}
    	if (i < 0) i = 0;

    	// some error handling for my sanity
    	if (if_tiers < 0){
    		throw new Error("get_foreach_end_pos ("+loop_tiers+") loop_tiers less than 0");
    	}
    	return {go_to: i-1}; 
    };



    /**
	  	Sets up the proper handlers for a user-created plugin during compilation.

	    @name fn.assign_plugin_handler
	    @private
	    @function
	    @param {String} The string containing the template command
	    @param {String} The string containing the variable names in question
	    @param {Object} The plugin object with name and compile-time/run-time functions
	    @returns {Object} A token object
	 */
    fn.assign_plugin_handler = function( $command, $varname, $plugin_obj ) {
    	var $steps = util.trim($varname).split('.'),
    		passdata = {};
		if (typeof $plugin_obj.compile_func !== 'undefined'){
    		passdata = $plugin_obj.compile_func($command);
    	}

    	var t_action = function($data, $pos) {
    		var object_var = util.object_rsearch( $steps, $data );
    		return $plugin_obj.runtime_func(object_var, passdata);
    	};
    	return {
    		type: $plugin_obj.name, 
    		action: t_action
    	};
    };


	/**
	  	Gets truthy or falsy value from variable and returns true or false

	    @name fn.determine_evaluate
	    @private
	    @function
	    @param {Any} A variable
	    @param {Boolean} Inverse modifier
	    @param {Any} A variable to compare against
	    @returns {Boolean} If the variable is truthy
	 */
	fn.determine_evaluate = function($target_var, $inverse, $comparison_var) {
		var target_type = util.get_type($target_var),
			evaluate = true;

		if ($comparison_var !== null) {
			// do a variable2variable comparison
			var comp_type = util.get_type($comparison_var);
			if (comp_type === 'number' || comp_type === 'boolean') {
				$comparison_var = $comparison_var.toString();
			}
			if ($comparison_var === 'false') {
				$comparison_var = '0';
			}
			if ($comparison_var === 'true') {
				$comparison_var = '1';
			}
			if (target_type === 'number' || target_type === 'boolean') {
				$target_var = $target_var.toString();
			}
			if ($target_var === 'false') {
				$target_var = '0';
			}
			if ($target_var === 'true') {
				$target_var = '1';
			}
			// because we converted a few values into strings, comparison is looser
			if ($target_var !== $comparison_var) {
				evaluate = false;
			}

		} else {
			// skip if blank array
			if (target_type === 'array') {
				if ($target_var.length === 0) {
					evaluate = false;
				}
			// skip if empty object
			} else if (target_type === 'object') {	
				evaluate = false;
				var name;
				for ( name in $target_var ) {
					evaluate = true;
					break;
				}
			// skip if string '0' by itself [TODO: this might not be good, get feedback]
			} else if ($target_var === '0') {
				evaluate = false;
			// skip if a falsey value
			} else if (!$target_var) {
				evaluate = false;
			}
		}

		// inverse modifier
		if ($inverse){
			evaluate = (!evaluate);
		}

		return evaluate;
	};



	//---------------------------------------------------------------------------------------------
	// Utilities


	/**
		Figures out and gathers all of the templates specified by the user in bowtie.compile
	   	Returns a single string containing an HTML template which has not yet been parsed.

	    @name util.compile_raw_template
	    @private
	    @function
	    @param {String} A string (of HTML or a keystring) or an array (of HTML or keystrings)
	    @returns {String} Either a string containing a raw html template, or false if failed.
	 */
	util.compile_raw_template = function($template_obj) {
		var object_type = util.get_type($template_obj),
			returned_template = '',
			valid = true,
			temp_template = '';

		if (object_type === 'string') {
			// if we have a bracket var, it's already a template, else we try to fetch it from the db
		    if (util.in_string($template_obj, reg_check_bowtie)) {
		    	returned_template = $template_obj;
		    } else {
		    	returned_template = util.fetch_template($template_obj);
		    }
		} else if (object_type === 'array') {
			// if $template_obj is an array, we loop through each element and concatenate the templates 
		    util.for_each($template_obj, function($key, $val){
		    	temp_template = util.compile_raw_template($val);
		    	if (temp_template !== false) {
		    		returned_template += temp_template;
		    	}
		    });
		} else {
		    valid = false;
		}

		// check for returned_template equalling false (in case we tried to fetch it)
		if (valid) {
			valid = returned_template !== false;
		}

		// check for empty string or all whitespace
		if (valid) {
			returned_template = returned_template.replace(reg_trim_ends, '');
			valid = returned_template !== '';
		}

		if (valid) {
			return returned_template;
		} else {
			console.error('ERROR: bowtie.populate: No valid template was passed and no valid template '+
				'key was specified. Check the value of the first parameter.');
		    return false;
		}
	};


	/**
	   	Searches through the collection of registered plugins and returns a proper match
	   	against the supplied string ($var_name)

	    @name util.get_var_mod_function
	    @private
	    @function
	    @param {String} The command tag which may or may not have a proper plugin command within
	    @returns {Object|Null} The plugin object or null
	 */
	util.get_var_mod_function = function($var_name) {
		var mod_func = null;
		util.for_each(registered_plugins, function($key, $val) {
			if ($var_name.indexOf($val.name) === 0) {
				mod_func = $val;
				return false;
			}
		});
		return mod_func;
	};


	/**
	   	Takes a template key and returns the corresponding string from template_cache

	    @name util.fetch_template
	    @private
	    @function
	    @param {String} The template key
	    @returns {String|Boolean} If the template is found, return it. Else, return false.
	 */
	util.fetch_template = function($template_key) {
		$template_key = $template_key.split('.');
		var templatehtml = util.object_rsearch($template_key, template_cache);
		if (templatehtml === null) {
			return '';
		} else {
			return templatehtml;
		}
	};


	/**
	   	Recursive search for a particular object property in an object tree

	    @name util.object_rsearch
	    @private
	    @function
	    @param {Array} The path of the search within the objects  - eg. ['employer', 'widgets', 'sidebar']
	    @param {Object} The pointer to the current object in the recursive search
	    @returns If the needle is found, return it. Else, return null.
	 */
	util.object_rsearch = function($obj_steps, $obj_pointer) {
		var local_obj_steps = $obj_steps.slice(0);
		if (local_obj_steps === undefined || $obj_pointer === undefined) {
			return null;
		}
		var next_path = local_obj_steps.shift(),
			steps_left = local_obj_steps.length,
			obj_type = util.get_type($obj_pointer);
		if (util.get_type(next_path) !== 'string' || (obj_type !== 'object' && obj_type !== 'array')) {
			return null;
		}

		// check for existance of .eq(#)
		if (next_path.indexOf('eq(') === 0) {
			next_path = parseInt(next_path.replace(/eq\(|\)|\s/, ''));
			// get the array object index
			if ($obj_pointer[next_path] !== undefined) {
				if (steps_left === 0) {
					return $obj_pointer[next_path];
				} else {
					return util.object_rsearch(local_obj_steps, $obj_pointer[next_path]);
				}
			} else {
				return null;
			}

		// unfortnately, if we are pointing to an array and the eq() isn't present, we cant progress so we're done
		} else if (obj_type === 'array') {
			return null;
		}

		// if everything validates, we check for the existence of the property and return the proper data
		if (next_path in $obj_pointer) {
			if (steps_left === 0) {
				return $obj_pointer[next_path];
			} else {
				return util.object_rsearch(local_obj_steps, $obj_pointer[next_path]);
			}
		} else {
			return null;
		}
	};


	/**
	   	Gets any object's length in terms of iterating over it in the parser

	    @name util.get_length
	    @private
	    @function
	    @param {Any} The object to be measured
	    @returns {Integer} The length of the object

	 */
	util.get_length = function(obj) {
		var size = 0, key, type  = util.get_type(obj);
		if (type === 'array') return obj.length;
		if (type !== 'object') return 1;
		for (key in obj) {
		    if (obj.hasOwnProperty(key)) size++;
		}
		return size;
	};


	/**
	   	Returns an array of properties to be iterated over

	    @name util.get_loopable_props
	    @private
	    @function
	    @param {Any} The object to be measured
	    @returns {Array} An array of the object's values
	 */
	util.get_loopable_props = function(obj) {
		var props = [], type  = util.get_type(obj);

		for (key in obj) {
			if (type === 'object'){
			    if (obj.hasOwnProperty(key)) props.push(obj[key]);
			} else if (type !== 'array') {
				props.push(obj);
				break;
			} else {
				props.push(obj[key]);
			}
		}
		return props;
	};


 	/**
	   	Does a regex search in a string and return true if that string is found in the haystack

	    @name util.in_string
	    @private
	    @function
	    @param {String} The haystack to search within
	    @param {String} The string to be found
	    @returns {Boolean} If the needle is found, return true. Else, return false.
	 */
	util.in_string = function($haystack, $needle) {
		$needle = (util.get_type($needle) === 'regexp')? $needle : new RegExp($needle, 'i');
		return $haystack.match($needle) !== null;
	};


    /**
	   	Removes all characters from a string except a-z, 0-9, dash, underscores, ampersands 
	   	and commas.

	    @name util.slugify
	    @private
	    @function
	    @param {String} A string to be made into a slug
	    @returns {String} A slugified string
	 */
	util.slugify = function ($string) {
		var slug_target = $string.toLowerCase();
	    slug_target = slug_target.replace(/[^-a-zA-Z0-9,&\s]+/ig, '');
	    slug_target = slug_target.replace(/-/gi, "_");
	    slug_target = slug_target.replace(/\s/gi, "-");
	    return slug_target;
	};

	/**
		Removes the whitespace from the beginning and end of a string.
		Uses Native trim function if possible

	    @name util.trim
	    @private
	    @function
	    @param {String} A string to be trimmed
	    @returns {String} A trimmed string
	 */
	util.trim = string_trim && !string_trim.call("\uFEFF\xA0") ?
		function( $text ) {
			return $text == null ?
				"" :
				string_trim.call( $text );
		} :

		// if no core trim, use our own trimming functionality
		function( $text ) {
			return $text == null ?
				"" :
				( $text + "" ).replace( reg_trim, "" );
		};


	/**
	   	Boolean function to see if an object is an array.

	    @name util.is_array
	    @private
	    @function
	    @param {Object} Any object
	    @returns {Boolean} True if an object is of type "array"
	 */
	util.is_array = Array.isArray || function ( $obj ) {
		return (util.get_type( $obj ) === "array");
	};


	/**
	   	Boolean function to see if an object is a function.

	    @name util.is_function
	    @private
	    @function
	    @param {Object} Any object
	    @returns {Boolean} True if an object is of type "function"
	 */
	util.is_function = function( $obj ) {
		return util.get_type( $obj ) === "function";
	};


	/**
	   	Checks to see if target is a "plain" object (taken from jQuery's is_plain_object() function)

	    @name util.is_plain_object
	    @private
	    @function
	    @param {Object} Any object
	    @returns {Boolean} True if an object satisfies all comparisons
	 */
	util.is_plain_object = function( $obj ) {
		// Must be an $object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window $objects don't pass through, as well
		if ( !$obj || util.get_type($obj) !== "$object" || $obj.nodeType || util.is_window( $obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be $object
			if ( $obj.constructor &&
				!object_hasOwnProp.call($obj, "constructor") &&
				!object_hasOwnProp.call($obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host $objects #9897
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.
		var key;
		for ( key in $obj ) {}

		return key === undefined || object_hasOwnProp.call( $obj, key );
	};


	/**
	   	Checks to see if target is the window object (taken from jQuery's is_window() function)

	    @name util.is_window
	    @private
	    @function
	    @param {Object} Any object
	    @returns {Boolean} True if an object satisfies all comparisons
	 */
	util.is_window = function( $obj ) {
		return  $obj != null &&  $obj ==  $obj.window;
	};


	/**
	   	Returns a string of the given object's type

	    @name util.get_type
	    @private
	    @function
	    @param {Object} Any object
	    @returns {String} True if an object is of type "array"
	 */
	util.get_type = function ( $obj ) {
		return ($obj === null)? 
				String($obj) 
				: ( class_types[ object_toString.call($obj) ] || "object" );
	};


	/**
	   	Returns the index of an object in an array, or -1 (taken from jQuery's inArray() function)

	    @name util.in_array
	    @private
	    @function
	    @param {Array} The needle
	    @param {Array} The Haystack
	    @param {Integer} The length counter
	    @returns {Integer} Index of match, or -1
	 */
	util.in_array = function( elem, arr, i ) {
		var len;

		if ( arr ) {
			if ( array_indexOf ) {
				return array_indexOf.call( arr, elem, i );
			}

			len = arr.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in arr && arr[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	};


	/**
	   	Loop through the properties of an object or elements of an array and apply
	   	a callback to each. (Taken from jQuery's each() function)

	    @name util.for_each
	    @private
	    @function
	    @param {Object} Any object
	    @param {Function} Any function to be called on every iteration
	    @param {Object} Any object to be passed to the callback
	    @returns {Object} The looped object param
	 */
	util.for_each = function( $obj, $callback, $args ) {
		var name,
			i = 0,
			length = $obj.length,
			isObj = length === undefined || util.is_function( $obj );

		/* 
			Loop over object properties and kill loop if any callback returns false
		*/

		// if $args is passed, we pass that to each callback function
		if ( $args ) {
			if ( isObj ) {
				for ( name in $obj ) {
					if ( $callback.apply( $obj[ name ], $args ) === false ) {
						break;
					}
				}
			} else {
				// NOTE: loop only once if not actually an object
				for ( ; i < length; ) { 
					if ( $callback.apply( $obj[ i++ ], $args ) === false ) {
						break;
					}
				}
			}

		// For the more common utilization, we fire this loop
		} else {
			if ( isObj ) {
				for ( name in $obj ) {
					if ( $callback.call( $obj[ name ], name, $obj[ name ] ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( $callback.call( $obj[ i ], i, $obj[ i++ ] ) === false ) {
						break;
					}
				}
			}
		}

		return $obj;
	};

	/**
		Returns a randomized 8-character string out of numbers and letters

	    @name util.random_hash
	    @private
	    @function
	    @returns {String} A hash string
	 */
	util.random_hash = function() {
	    var text = "",
	        possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
	        i = 0;

	    for(; i < 8; i++ ) {
	        text += possible.charAt(Math.floor(Math.random() * possible.length));
	    }

	    return text;
	};


	/**	
	   	Takes two or more objects and merges their properties together 
	   	(Taken from jQuery's extend() function)

	    @name util.object_merge
	    @private
	    @function
	    @param Arguments array (not in function declaration)
	    @returns {Object} The merged object
	 */
	util.object_merge = function() {
		var options, name, src, copy, copyis_array, clone,
				target = arguments[0] || {},
				i = 1,
				length = arguments.length,
				deep = false;

			// Handle a deep copy situation
			if ( typeof target === "boolean" ) {
				deep = target;
				target = arguments[1] || {};
				// skip the boolean and the target
				i = 2;
			}

			// Handle case when target is a string or something (possible in deep copy)
			if ( typeof target !== "object" && !util.is_function(target) ) {
				target = {};
			}

			// extend bowtie functions itself if only one argument is passed
			if ( length === i ) {
				target = fn;
				--i;
			}

			for ( ; i < length; i++ ) {
				// Only deal with non-null/undefined values
				if ( (options = arguments[ i ]) != null ) {
					// Extend the base object
					for ( name in options ) {
						src = target[ name ];
						copy = options[ name ];

						// Prevent never-ending loop
						if ( target === copy ) {
							continue;
						}

						// Recurse if we're merging plain objects or arrays
						if ( deep && copy && ( util.is_plain_object(copy) || (copyis_array = util.is_function(copy)) ) ) {
							if ( copyis_array ) {
								copyis_array = false;
								clone = src && util.is_array(src) ? src : [];

							} else {
								clone = src && util.is_plain_object(src) ? src : {};
							}

							// Never move original objects, clone them
							target[ name ] = util.object_merge( deep, clone, copy );

						// Don't bring in undefined values
						} else if ( copy !== undefined ) {
							target[ name ] = copy;
						}
					}
				}
			}

			// Return the modified object
			return target;
	};



	//---------------------------------------------------------------------------------------------
	// Initialization and modifier setup functions


	// push data into the class_types object
	util.for_each("Boolean Number String Function Array Date RegExp Object".split(" "), function($i, $name) {
		class_types[ "[object " + $name + "]" ] = $name.toLowerCase();
	});


	// Below are some plugins (aka modifiers) that are fired during the variable_render phase:

	// slugify
	bt.register_plugin('slug', function($var_value) {
		if (util.get_type($var_value) !== 'string') {
			return $var_value;
		}
		return util.slugify(util.trim($var_value));
	});

	// escape quotes
	bt.register_plugin('escape_quotes',  function($var_value) {
		return $var_value.replace(/"/g, '&quot;');
	});

	// truncate (both compile-time and run-time functions)
	bt.register_plugin('truncate', 
		// compile-time function
		function( $command_string ){ 
			var trim_amount =  $command_string.match(/\(([0-9]{1,100})\)/g);
	        if (trim_amount !== null) {
	            trim_amount = trim_amount[0].replace(/\(|\)/g, '');
	            trim_amount = parseInt(trim_amount);
	        }
	        return trim_amount; // return this variable ...
		}, 
		// run-time function
		function( $var_value, $trim_length ) { // ... which gets passed to the run-time function here
			var addon = '...';
			if (typeof $var_value !== 'string') {
				return '';
			} else {
	            if ($var_value.length < $trim_length - 3) {
	            	addon = '';
	            }
	            return $var_value.substr(0, $trim_length) + addon;
			}
		}
	);

	// bt_fullname (demo modifier)
	// An example of how to use this like a Handlebars "helper"
	bt.register_plugin('bt_demo_fullname', function($var_value) {
		var firstname = $var_value.first || '';
		var lastname = $var_value.last || '';
		return util.trim(firstname+' '+lastname);
	});



	//---------------------------------------------------------------------------------------------
	// Send bowtie out into the world...

	thewindow.bowtie = bowtie_app();

})( thewindow );